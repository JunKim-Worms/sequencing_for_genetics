## 유전학자를 위한 시퀀싱 자료 분석
## 목록
- [분노가 사람을 만든다 - 왜 배워야 하는가](#rages_maketh_man)
- [존잘이 너무 많다 - 시퀀싱을 이용한 실험들](#sequencing_experiments)
  - [유전체 이어붙이기(Genome assembly)](#genome_assembly)
  - [원인 돌연변이 찾기 Mapping-by-sequencing](#map_by_seq)
  - [Genome-wide association mapping](#gwas)
  - [RNA 정량 및 통계처리](#rnaseq)
  - [크로마틴 접근성 확인](#atacseq)
  - [크로마틴 구조 확인](#hic)
  - [그 외 다양한 시퀀싱 기법들](#etc)
- [까만 바탕에 하얀 글씨-리눅스에서 작업 하기](#linux_tutorial)
- [염기서열을 다뤄보기](#atgc)
- [코딩을 하지 않는 방법](#no_coding_scripting)
- [공공 자료에 빨대 꽂기](#public)
- [어떤 유전자가 열심히 일하나](#rnaseq101)

## <a name="rages_maketh_man"></a> 분노가 사람을 만든다 - 왜 배워야 하는가

이 자료는 다양한 분노가 쌓여 작성됐습니다.

제가 지인 중 하나는 컴퓨터공학을 공부했고 생명쪽 자료를 잘 다룬다는 것을 늘상 자랑했습니다. 멍청하고 경험 없던 저는 그 말에 홀랑 넘어갔고, 위대하신 박사 지도교수 빛☆준☆호 선생님께 그 인간을 소개시켜드리는 큰 죄를 저질러 버리고 말았습니다. 그 중생은 일을 전혀 하지 않으면서 미루기만 했고, 참다참다 이제는 못 참겠다 싶어 제가 직접 분석하기 시작했습니다. 이제 막 공부하는 과정이었는데도 시작하고 보니 그 새기가 1-2년을 끌어온 일을 한두 달만에 끝낼 수 있게 됐고, 그 새기가 싼 똥 치우고 새로 똥을 쌀 때마다 쌍욕 오지게 하면서 경험치를 쌓게 됐습니다. 그리고 [**시퀀싱 자료 분석을 통해 만들어낸 유전학 논문**](https://genome.cshlp.org/content/29/6/1023)으로 박사 졸업을 하게 됐습니다.

당시 저는 정신이 피폐해 주변 생물학자들을 만날 때마다 이런 유형을 신나게 욕하고 다녔는데, 저와 비슷하게 고통을 받았다는 이들이 한둘이 아니었습니다. "데이터 분석 잘 한다고 해서 공동1저자/공동교신저자 걸고 일을 시작했는데 정작 분석을 너무 늦게 해서 진행이 안 됐다." "분석 열심히 했다고 하면서 한참 뒤에 결과 보내줬는데, 그만큼 시간 걸릴 일인 건지 모르겠다." "그림 하나 그려놓고 공동1저자 달라고 하는데, 그만한 분석인지 모르겠다." 세상에 날로 먹으려는 훌륭한 분들이 이렇게나 많았다니! 역시 분석을 할 줄 아느냐가 중요한 게 아니었습니다.

그 연구가 어떤 목적으로 계획됐고, 어떤 실험을 통해 논리를 만들고 있으며, 해당 대용량 자료 분석 결과에 대해 어떤 맥락에서, 어느 정도의 증거력을 기대하면서, 무슨 결론을 내야 하는지, 제대로 이해할 수 있는 사람만이 자료를 정확하게 분석할 수 있다는 지극히 당연한 사실을 깨닫게 됐습니다.

바로 **연구자 본인** 말입니다.

반대로 제가 공동연구를 하면서 **제대로 생산되지 않은 시퀀싱 자료가 차고 넘친다**는 것도 알게 됐습니다. 시퀀싱 또한 하나의 실험이고 가설을 검증하는 과정이기 때문에 제대로 된 대조군을 시험해야 하고, 시퀀싱으로 할 수 있는 어떤 실험이 있는지 명확하게 알아야 하며, 각 실험을 대체할 수 있는 것은 또 무엇이 있는지 알아야 한다는 걸 이해하게 된 것입니다. 각 시퀀싱 실험을 할 때 어떤 대조군이 있어야 더 명확하고 선명한 결과를 얻을 수 있는지 알려주는 교육이 없으니 당연한 결과 아니겠습니까? 저만 해도 학부 때나 대학원 때 분석 관련 수업을 배울 수 없었고, 비슷한 수업을 들어본 친구들 얘기로는 자기가 원하는 자료 분석과는 거리가 먼 수업이었다고도 합니다. 결국 독학할 수밖에 없는 형편이었습니다.

그래서 연구실과 공동연구하는 동료들을 위해 자료를 만들기 시작했고, 그렇게 만들어낸 **임시방편 교육 자료**가 이 교육 자료입니다. 앞으로 여러분은 다음 내용을 공부하게 될 것입니다. 각 자료는 읽는 데 30분에서 1시간, 실습하는 데 2-6시간 정도 들이면 충분합니다. 난이도는 들쭉날쭉합니다만, 제 어머니나 할머니는 못하더라도 **지도교수님은 따라할 수 있는 수준**(**Even my PI!**)으로 잡았습니다. 또 이 세상에 존재하는 모든 분석법을 익히는 것을 목표로 하진 않습니다. 그보다는 굉장히 제한적인 DNA와 RNA 시퀀싱 자료 분석법을 익히게 될 것입니다. 대신, 다 끝낸 뒤에는 본인이 원하는 실험에 적절한 새로운 방법론을 스스로 찾고 스스로 분석할 수 있도록 경험을 쌓는 것을 목표로 하고 있습니다. 그때가 되면 적어도 "이게 하면 되는 거였구나!"라는 자신감이 붙게 될 테고, 몇몇은 지금까지 공동연구자들이나 회사가 똑바로 하지 않았다는 것을, 또는 기대 이상으로 정말 잘해주고 있었다는 것을 깨닫게 될지 모르겠습니다.


## <a name="sequencing_experiments"></a> 존잘이 너무 많다 - 시퀀싱을 이용한 실험들
세상에는 위대한 분들이 넘쳐나고, 그들이 만들어낸 온갖 시퀀싱 실험 기법과 분석 기법이 넘쳐 납니다. 시퀀싱은 그저 DNA나 RNA 등이 어떤 서열을 지니고 있는지 빠르게 읽어내는 방법에 지나지 않지만, 이 두 분자가 워낙에 중요해야죠. DNA 서열 정보, RNA 서열 정보만으로도 알아낼 수 있는 것이 정말 많습니다. 이번 글에서는 널리 쓰이는 시퀀싱 실험 기법과 각 기법으로 살펴볼 수 있는 생명현상이 무엇인지 가볍게 알아보려고 합니다.

현존하는 시퀀싱 기법을 나누는 방법이야 여러 가지가 있겠지만, 저는 크게 짧은 리드(read)와 긴 리드 시퀀싱으로 나눠서 설명하는 편입니다. 안타깝게도 현존하는 기법으로는 염색체 하나를 처음부터 끝까지 통째로 읽어내는 것이 불가능하기 때문에, 특정 길이로 잘린 DNA 등을 읽어내는 수밖에 없습니다. 이렇게 **한번에 읽어낸 DNA 또는 RNA**를 리드라고 부릅니다. 짧은 리드 시퀀싱은 값이 훨씬 싸고 정확한 대신 100-200 bp 정도로 리드 길이가 짧습니다. 긴 리드 시퀀싱은 값도 비싸고 상대적으로 부정확하지만, 리드 길이가 평균 10,000-100,000 bp에 이를 만큼 훨씬 더 긴 길이를 한번에 읽어낼 수 있습니다. 이 때문에 몇 가지 장점을 지니는데, 복잡한 염색체 지역의 정보를 확인하거나 유전자의 서로 다른 아이소폼(isoform)을 확인할 때 특히 더 좋습니다.

[BRIC View, 길이가 긴 리드를 이용한 염기서열분석의 응용, 아래 논문 요약본](https://www.ibric.org/myboard/read.php?Board=report&id=3149)\
[Piercing the dark matter: bioinformatics of long-range sequencing and mapping](https://www.nature.com/articles/s41576-018-0003-4)\
[Long-read human genome sequencing and its applications](https://www.nature.com/articles/s41576-020-0236-x)

#### <a name="genome_assembly"></a>유전체 이어붙이기(Genome assembly)
한번에 염색체 처음부터 끝까지 이어붙일 수 없다면 우리가 쓰고 있는 표준 유전체는 어떻게 만들어낼 수 있었던 걸까요? 같은 자리를 여러 번 읽고, 퍼즐 맞추듯 겹치는 부분을 이어붙여서 만들어냈습니다. 최근 긴 리드 시퀀싱 기법이 발전하면서 이 과정이 훨씬 더 쉬워졌는데, 이 때문에 약 5조 원 정도를 들여 지구에 살고 있는 온갖 진핵생물의 표준 유전체를 만들겠다는 야심찬 프로젝트가 시작되기도 했습니다. 제 밥벌이 방법론이니 공동연구 필요하신 분은 연락주시면 되겠습니다.

[Earth BioGenome Project 홈페이지](https://www.earthbiogenome.org/)\
[Earth BioGenome Project: Sequencing life for the future of life](https://www.pnas.org/content/115/17/4325)\
[Darwin Tree of Life 홈페이지](https://www.darwintreeoflife.org/)

#### <a name="map_by_seq"></a>원인 돌연변이 찾기 Mapping-by-sequencing
정방향 유전학(forward genetics)은 20세기 중후반부터 온갖 모델생물에 적용되며, 각 형질에 영향을 주는 수많은 유전자를 알 수 있도록 해준 대애단한 방법론입니다. 이는 돌연변이 유발 물질을 처리해 온갖 유전자에 돌연변이를 만들어내고, 그 중 원하는 표현형 변이를 지니는 개체를 골라내, 그 개체가 지니고 있는 돌연변이 중 어떤 유전자에 생긴 돌연변이가 그 표현형 변이를 만들어냈을지 찾아내는 과정을 포함합니다. 이 원인 돌연변이를 찾는 일은 몇 년 전까지만 해도 정말 고통스러운 일이었지만, 예쁜꼬마선충 기준, 작정하고 실험한다고 치면, 이제는 1-2주 정도면 그 원인 유전자를 매우 빠르게 좁혀낼 수 있습니다. 이해하기 가장 쉬운 예는 recessive이고 penetrance가 100%이며 표현형이 non-lethal or non-sterile일 때입니다. 돌연변이를 만들어낸 계통(A)과 유전적으로 거리가 먼 야생 계통(B)을 짝짓기 시켜 F1을 얻어내고, F2를 엄청나게 얻어 그 중 표현형이 나타난 개체만 골라내 하나로 섞어 한번에 DNA를 뽑습니다. 이러면 대부분의 locus는 A 유형과 B 유형이 마구잡이로 뒤섞여 시퀀싱 후 각각이 50%에 가깝게 나타날 테지만, 그 표현형에 관련된 돌연변이가 있는 locus는 모두 똑같이 A 유형으로 선택됐을 테니 특정 지역은 A가 100%로 나타날 것입니다. 만약 recombination이 자주 일어나는 종이라면 F2를 50-100마리만 골라내도 순식간에 원인 돌연변이를 찾아낼 수 있게 됩니다.

[관련 분석을 자동화해 그림까지 다 그려주는 MiModD](https://mimodd.readthedocs.io/en/latest/)\
[*Caenorhabditis elegans* mutant allele identification by whole-genome sequencing (original paper)](https://www.nature.com/articles/nmeth.1249)

#### <a name="gwas"></a>Genome-wide association mapping
정방향 유전학처럼 효과 크기(effect size)가 크고 단일 유전자 변이로 인해 생기는 표현형 변이를 연구할 수도 있지만, 이미 자연에 넘쳐나는 자연 변이(natural variation)를 이용해 해당 표현형 관련 유전자와 그 변이를 찾아낼 수도 있습니다. 가장 대표적인 예는 유전형과 표현형이 조금씩 다른 다양한 야생 개체를 채집하여 표현형을 측정하고 시퀀싱으로 유전형을 확인한 뒤 둘 사이의 상관관계를 확인하는 genome-wide association mapping 방법입니다. 연구실에서 쉽게 키울 수 없는 생물에서도 쉽게 쓸 수 있다 보니 다양한 작물이나 사람에게 널리 적용되고 있는 방법론입니다.

#### <a name="rnaseq"></a> RNA 정량 및 통계처리
샘플 수가 적은 실험을 계획할 때 RNA 정량화만큼 예쁜 그림 만들 수 있는 실험도 드물 겁니다. 각 유전형에 따라 다르게 나타나는 RNA 양은 그 자체로 좋은 표현형이고, 특정 유전형에 따라 유전자들의 발현이 어떻게 바뀌는지 살핌으로써 해당 유전형이 끼치는 영향까지도 알아낼 수 있습니다. 게다가 나이, 약품 처리 여부, 스트레스 여부 등 온갖 조건을 바꿔가며 손쉽게 살펴볼 수 있다는 장점도 있습니다. 물론 제대로 된 RNA 정량 비교 실험은 그만큼 비싸기도 해서 보통 마지막 그림을 아름답게 장식해서 논문 값을 좀 더 높여주거나 새로운 가설을 제안할 수 있는 용도로 많이 쓰이곤 합니다. 요새는 개별세포 하나하나에서 각 유전자의 발현 정도를 비교할 수 있는 기법도 활발하게 개발되고 있죠. 워낙 많이 쓰는 방법이라 [RNA 정량 및 통계처리](#rnaseq101)에서 더 자세하게 다룰 예정입니다.

#### <a name="atacseq"></a> 크로마틴 접근성 
쉽고도 강력한 기법인 ATAC-seq은 히스톤(histone) 단백질로 감겨 있지 않은 열린 크로마틴 지역을 탐색할 수 있게 해줍니다. 이 실험은 Tn5라는 독특한 transposase를 이용하는데, Tn5는 크로마틴으로 감기지 않은 DNA 서열로 끼어들어가면서 원래 트랜스포존이 그렇듯 양끝에 특정한 DNA 서열을 붙여줍니다(Tagmentation). 히스톤으로 감기지 않은 지역에는 동시에 여러 Tn5 효소가 끼어들어갈 수 있게 되고, 이들이 양끝에 남긴 특정 서열을 이용해 곧바로 시퀀싱할 수 있게 됩니다. 워낙 실험이 편한 데다 가성비가 좋아서 개별세포 수준에서도 다양한 기법이 개발돼 있습니다.

[Transposition of native chromatin for fast and sensitive epigenomic profiling of open chromatin, DNA-binding proteins and nucleosome position](https://www.nature.com/articles/nmeth.2688)\
[Tn5 transposase and tagmentation procedures for massively scaled sequencing projects](https://genome.cshlp.org/content/24/12/2033)

#### <a name="hic"></a> 염색체 구조 확인
염색체는 핵 속에서 복잡한 구조(conformation)로 접히고 묶여 있습니다. 이런 구조는 특정 유전자가 더 잘 작동하게 하는 데에 도움을 주기도 하며 핵 속에서 염색체가 작동하는 방식에 대한 이해를 높여줄 것이기 때문에 다양한 실험기법이 개발되고 있습니다. 가장 대표적인 것은 Hi-C라 부르는 실험 기법으로, (1) 핵에 화학 물질을 처리해 가까운 DNA 분자끼리 교차 결합(crosslink)을 형성하도록 하고, (2) 제한효소(restriction enzyme)를 처리해 DNA를 조각 낸 뒤, (3) 라이게이션(ligation)으로 교차결합을 형성한 DNA 분자끼리 이어지도록 만들어 시퀀싱하는 기법입니다. 이런 실험 기법으로 인해 1차원 DNA 서열에서는 분명히 멀리 떨어져 있던 두 지역이 함께 시퀀싱되는 결과가 나타나며, 이를 통해 어떤 DNA 서열끼리 핵 안에서 더 가까이 있는지 추정할 수 있습니다. 노이즈가 매우 심하고 여전히 값이 꽤 비싼 실험이라서, 지금도 더 발전시키려는 노력이 계속 되고 있습니다.

[Comprehensive Mapping of Long-Range Interactions Reveals Folding Principles of the Human Genome](https://science.sciencemag.org/content/326/5950/289.long)

#### <a name="etc"></a> 그 외 다양한 시퀀싱 기법들
앞서 언급한 실험 기법들 외에도 세상에는 엄청나게 많은 시퀀싱 실험 기법이 존재하며, 이를 통해 다양한 생명 현상을 high throughput으로 연구할 수 있게 됐습니다. 또 이런 실험 기법을 표준화하려는 노력이 국제 연구 협력체인 컨소시엄(consortium) 수준에서 지속되고 있으며, 가장 대표적인 ENCODE에서는 관련 실험 기법은 물론, 해당 실험 결과를 표준화된 형태로 전처리 및 분석해주는 컴퓨터 실험 기법까지도 제공하고 있습니다.

[Perspectives on ENCODE](https://www.nature.com/articles/s41586-020-2449-8)\
[ENCODE 관련 정보가 담긴 홈페이지](https://github.com/ENCODE-DCC)

이처럼 이미 존잘님들이 온갖 기법을 개발해두고 분석할 수 있는 길을 마련해둔 상태입니다. 그러니 우리 같은 인민들은 괜히 새로 개발하겠다고 까불고 다닐 일이 아니라, 그저 남들이 잘 갖춰둔 형태로 따라 쓰고 베껴 쓰면 될 일입니다.

혹시 지금까지 컴퓨터 배워보겠다고 파이썬이나 R 문법부터 배우려고 시도했던 경험을 갖고 계실지 모르겠습니다. 확실하게 말씀 드리자면, 처음부터 그렇게 가면 거의 90%는 자빠질 겁니다. 코딩하지 마세요. 컴퓨터로 실험하고 분석하는 법을 가장 빠르게 배우는 길은 [코딩하겠다고 까불지 않는 것](#no_coding_scripting)입니다. 존잘님을 따르십시오. 우리 같은 똥멍청이들이 생각할 만한 건 이미 존잘님들이 다 해뒀으니, 그저 어딘가에 계실 존잘님들을 향해 큰절 세 번 하고 복붙하며 베껴 씁시다.

다음 자료에서는 남의 분석법을 베껴쓰는 데 절실하게 필요한 Linux 커맨드라인 사용법에 대해 배워보겠습니다.


## <a name="linux_tutorial"></a> 까만 바탕에 하얀 글씨-리눅스에서 작업 하기

이번에는 리눅스에서 작업하는 방법에 대해 배워볼 것입니다. "왜 윈도우즈를 안 쓰고 이상한 걸 배워야 하나요?"라고 질문할 수도 있습니다. 이유는 단순한데, 직접 개발 안 하고 남들이 개발한 거 가져다 쓰려면 어쩔 수가 없습니다. 거의 대부분의 계산 도구들이 리눅스 기반으로 개발되어 있거든요. 우리 목적은 쉽게 쉽게, 직접 개발하기는 커녕 코딩도 안 하고 분석하는 방법을 익히는 것이니, 쉽고 재미있게 리눅스에서 작업하는 법을 배워봅시다. 이번주부터는 본격적인 실습과 숙제가 시작됩니다.

리눅스에서 작업하는 법을 배우려면 가장 먼저 리눅스 기반의 컴퓨터나 서버를 구해야 합니다. 대부분은 없을 테지만 걱정하지 않으셔도 됩니다. 위대하신 빛혜식 선생님(@heyshik)께서 대안을 찾아주셨거든요. 항상 충성충성입니다.

먼저 다음 링크로 들어가 회원 가입을 하십시다. 국가수리과학연구소에서 제공하고 있는 사용하시기 전에 대전을 향해 세 번 절하고 쓰시면 좋을 것 같습니다. 매주 월요일인가 리셋된다고들 하니 한번에 몰아서 숙제하시면 되겠습니다.

https://jupyter.nims.re.kr/

회원가입 후 로그인하면 왼쪽 위에 **Jupyter**라고 적힌 창이 뜰 텐데, 오른쪽 위, 로그아웃 아래 쪽에 있는 **New** 클릭하시면 됩니다. 그 뒤 가장 아래에 있는 **Terminal**을 클릭하시면 리눅스 연습할 수 있는 화면이 뜹니다. 처음 연결하시면 까만 바탕에
```console
어쩌구@저쩌구:~/work$
```
라고 뜨고, 그 옆에 하얀색으로 커서가 뜰 것입니다. 접속 끝입니다.

이제 리눅스에서 작업할 준비가 끝났습니다. 겁먹을 필요는 없습니다. 제가 지금까지 석사 과정, 박사 과정, 교수급 등 다양한 분들에게 가르쳐봤는데, 이 단계는 모두 쉽게 통과했습니다. 완전 집중하고 실습한다고 가정했을 때, 보통 약 2-4시간 정도 걸리는 것 같습니다.

먼저 가장 기본이 되는 몇 가지 명령어에 대해 배워봅시다. 평소에 윈도우즈 쓰는 것과 엄청나게 다르진 않은데, 마우스 대신 **커맨드 라인**이라고 부르는 키보드 기반 환경에서 작업한다는 게 가장 큰 차이점입니다. 참고로 직접 서버를 세팅하시거나 맥 등을 이용하신다면 마우스로도 똑같이 작업할 수 있으니 나중에 한번 해보세요. 일단은 커맨드 라인에 익숙해져 봅시다.

커맨드 라인이라는 이름 그대로, 명령어를 한 줄 한 줄 입력해서 컴퓨터에게 일을 시킬 수 있습니다. 가장 간단한 명령어를 몇 가지 직접 쳐봅시다. 먼저 `ls`를 치고 엔터키를 누르시면 됩니다.

```sh
ls
```

`ls`는 list의 약자로, 현재 폴더에 어떤 것들이 들어있는지 보여주라는 명령어입니다.

```sh
nano test
```
`nano`는 메모장을 여는 명령어입니다. **한 칸을 띄운 뒤** 특정 단어를 적으면 해당 이름을 지닌 파일을 열어줍니다. 만약 그 이름을 가진 파일이 없다면 새로운 파일을 생성하게 됩니다. `ctrl+x`를 누르시면 빠져나올 수 있습니다. 윈도우즈와 다른 점이 하나 있는데, **확장자**를 굳이 쓰지 않아도 된다는 것입니다. 윈도우즈처럼 `.txt` 등으로 끝나지 않아도 텍스트 파일입니다.

```sh
mkdir test
cd test
```

`mkdir`은 make a new directory, 즉 새로운 폴더를 만들어주는 명령어입니다. 마찬가지로 **한 칸을 띄운 뒤** 특정 단어를 적어주면 그 이름을 지닌 폴더를 생성해줍니다. `cd`는 change your working directory, 즉 특정 폴더로 옮겨주는 기능을 지니고 있습니다. 마찬가지로 **한 칸을 띄운 뒤** 특정 단어를 입력하면 그 이름을 지닌 폴더로 이동해줍니다. 아무것도 입력하지 않으면 홈(home) 폴더로 이동시킵니다. `~` 이 물결 표시가 여러분의 홈 폴더(/home/id)의 약자입니다.

여기서 중요한 개념을 하나 배워야 하는데, 상대경로(relative path)와 절대경로(absolute path)입니다. **상대경로**는 A가 B라는 집을 소개할 때 "B는 우리집에서 동쪽 방향의 옆집에 살지."라고 표현하는 것과 비슷합니다. A의 집을 안다면 손쉽게 찾아갈 수 있다는 장점을 지니고 있습니다. 다만 "B는 동쪽으로 두 건물, 북쪽으로 두 건물, 그 건물에서 3개 층 올라가면 나오는 집에 살고 있다" 등으로 너무 복잡하다면 "서울시 관악구 관악로 1 서울대학교"라고 표현하는 것이 훨씬 더 편할 수도 있습니다. 이렇게 접근하는 방식을 **절대경로**라고 부릅니다.

먼저 커맨드 라인에 `cd`를 입력해보십시오. `$` 표시 다음에 뜬 명령어만 치시면 됩니다.
```console
foo@bar:~/work/test$ cd            # 현재 폴더인 ~/work/test 폴더에서
foo@bar:~$                         # 홈 폴더로 이동함
foo@bar:~$ ls                      # 현재 홈 폴더에는 더 이상 test 폴더가 존재하지 않고, work 폴더만 존재함
```

만약 이 홈 폴더에서 `cd test`를 친다고 하면 다음과 같은 오류 메시지가 나타날 것입니다.
```sh
bash: cd: test: No such file or directory
```
왜냐면 **현재 폴더 안**에는 `test`라는 폴더가 존재하지 않기 때문입니다. 이처럼 **현재 폴더를 기준으로** 폴더 위치를 찾아나가는 방법을 **상대경로**라고 부릅니다. 현재 폴더보다 **아래에** 있는 폴더는 그냥 폴더 이름만 치면 된다는 장점이 있습니다. 다음 명령어들을 따라서 쳐봅시다.

```console
foo@bar:~$                         # 홈 폴더
foo@bar:~$ cd work                 # 현재 폴더인 ~ 폴더에서 ~/work 폴더로 이동
foo@bar:~/work$ cd                 # 다시 홈 폴더로 이동
foo@bar:~$ cd work/test            # 현재 폴더에서 두 단계 아래에 있는 폴더로 이동
foo@bar:~/work/test$ cd ..         # 현재 폴더보다 한 단계 위에 있는 폴더로 이동
foo@bar:~/work$ cd ../..           # 현재 폴더보다 두 단계 위에 있는 폴더로 이동
foo@bar:/home$
```

그런데 몇몇 경우에는 상대경로를 이용하는 게 굉장히 귀찮을 때가 있습니다. 예컨대 현재 폴더와 이동해야 할 폴더 사이의 관계를 모른다거나, 그 거리가 너무 멀어 `..`과 폴더 이름을 매우 여러 번 쳐야 할 때가 그런 예입니다. 이럴 때는 **절대경로**를 이용해 보다 편하게 이동할 수 있습니다.

절대경로는 현재 폴더가 어디이건 관계 없이 항상 일정합니다. 절대경로는 항상 `/` 에서 시작하는데, 이 시작점을 루트(root)라고 부릅니다. 다음 경로로 한 번 이동해봅시다.

```console
foo@bar:/home$ cd /                # 루트로 이동
foo@bar:/$ cd                      # 홈 폴더로 이동
foo@bar:~$                         # 홈 폴더
foo@bar:~$ cd /opt/conda/bin       # 절대경로를 통해 특정 폴더로 이동
foo@bar:/opt/conda/bin$            # 홈 폴더 아래에 있는 폴더가 아니라서 ~로 시작하지 않음
```

윈도우즈에서 쓰는 파일 시스템과 비슷하죠? 마우스 클릭 대신 cd로 이동한다는 것이 다를 뿐입니다. 참고로, 키보드에 있는 `Tab` 키를 이용하면 이동이 더 쉬워집니다.

```console
foo@bar:/opt/conda/bin$ cd         # 홈 폴더로 이동
foo@bar:~$ cd w                    # w만 치고 Tab 키 누르기
foo@bar:~$ cd work/                # 자동완성됨
```

이외에도 굉장히 많은 명령어가 있습니다만, 다 가르쳐드리면 실력이 늘질 않으니 익혀야 하는 리스트를 드리겠습니다. 대부분의 명령어는 `ls --help`처럼 명령어를 치고 **한 칸 띄운 뒤** `--help`를 치면 간략한 설명서를 띄워줍니다. 여기서도 안 나온다면 (물론 그럴 일은 거의 없습니다) 구글에 열심히 검색하면서 찾아보시면 되겠습니다. 대부분이 똑같은 얘길 하면서 알려줄 것입니다. 바로 **RTFM**, "Read the f****** manual"의 약자입니다. 항상 매뉴얼 먼저 읽고 따라하는 습관을 생활화합시다. 물론 매뉴얼이 이해가 안 될 가능성도 매우 높습니다만, 그럴 땐 구글에 검색해서 찾아봅시다(리눅스 ls 사용법 또는 linux ls usage 등등). 여러분과 같은 중생들이 도처에 널려 있고, 깨달음을 얻은 부처들이 욕은 하면서도 결국 여러분을 구제해줄 것입니다.

명령어를 그냥 입력하면 지루하게 배우겠죠? 텍스트를 읽으면서 좀 더 재밌게 명령어를 익힐 수 있는 게임이 있으니 그걸 이용해봅시다. 이름은 보물 찾기(Treasure Hunter)로, UCSF에 계시는 Stephan J. Sanders 박사가 개발한 것입니다. 제가 번역 초안을 맡았고 시바님이 감수해주셨습니다. 사용법은 다음과 같습니다. 일단 홈 폴더로 이동한 뒤 다음 명령어를 치고 엔터를 눌러주세요.

```
mkdir treasure && cd treasure
git clone https://github.com/JunKim-Worms/unix_tutorial.git
perl unix_tutorial/treasureHunt_v2_kor.pl
rm -rf unix_tutorial/
```

각 줄(line)이 어떤 의미인지는 차츰 알게 될 겁니다. 예컨대 세 번째 줄에 있는 `treasureHunt_v2_kor.pl` 파일이 보물 찾기 게임을 실행해주는 파일입니다. 이 게임은 Perl이라는 프로그래밍 언어로 짜였습니다. `.pl` 이라는 확장자로 끝나면 `perl file.pl` 등으로 실행할 수 있습니다.
파일들이 잘 생성됐다면 이제 nano 또는 cat을 이용해 단서를 열고 읽어봅시다.
```sh
cat Clue01_S.txt # or nano Clue01_S.txt
```

원래 보물찾기가 끝나면 선물을 달라고 하시면 되는데, COVID-19이 끝날 즈음 서울대로 찾아오시면 차라도 한 잔 대접하겠습니다.

보물찾기가 끝나면 다음 링크를 클릭해서 들어가서 시키는 대로 하시면 됩니다.\
[1주차 숙제](https://github.com/JunKim-Worms/sequencing_for_genetics/blob/master/week1/hw1.md)\
숙제 파일은 다음 명령어를 커맨드 라인에 입력하면 다운 받을 수 있습니다.
```sh
git clone https://github.com/JunKim-Worms/sequencing_for_genetics.git
cd sequencing_for_genetics/week1/
```

#### 컴퓨터 세팅 관련
참고로 저는 처음에 리눅스 컴퓨터 세팅하는 것부터 배웠는데, 고통스러웠지만 상당히 재밌는 작업이었습니다. 이번 튜토리얼을 다 끝낸 뒤 본격적으로 작업해보고 싶으신 분들은 어딘가 남는 컴퓨터 하나 있다면 싹 밀고 우분투 18.04 설치 등을 검색해서 설치해보셔도 좋을 것 같습니다. 저는 익숙해지는 데 3-6개월 정도 걸렸습니다만, 좀 더 빠르게 해보실 수도 있을 겁니다. 연구실에 직접 세팅하고 쓰실 분들은 업체에 설치 및 관리 등을 맡기시는 것도 좋습니다. 선충 분석용 컴퓨터는 약 500-700만 원 정도 들 텐데, 그 정도면 제가 냈던 [Genome Research 논문]에 들어간 분석은 아주 빠르게 할 수 있는 수준입니다.
